{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "from pyspark import SparkConf, SparkContext\n",
    "\n",
    "sc._conf.setAll([('spark.executor.memory', '8g'), \n",
    "                 ('spark.executor.cores', '8g'), \n",
    "                 ('spark.cores.max', '8g'),\n",
    "                 ('spark.driver.maxResultSize', '10g'), \n",
    "                 ('spark.driver.memory','45g')])\n",
    "\n",
    "conf = SparkConf().setMaster(\"local[*]\").setAppName(\"SNA\")\n",
    "sc = SparkContext(conf=conf)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 1. data: zachary karate club dataset\n",
    "+ 34 members in the club\n",
    "+ 78 edges in total \n",
    "+ undirected\n",
    "+ unweighted"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "@inproceedings{nr,\n",
    "     title={The Network Data Repository with Interactive Graph Analytics and Visualization},\n",
    "     author={Ryan A. Rossi and Nesreen K. Ahmed},\n",
    "     booktitle={AAAI},\n",
    "     url={http://networkrepository.com},\n",
    "     year={2015}\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## (1) Summary\n",
    "+ neighbors_dict: 每一個member周圍所有有聯結的member\n",
    "  ex. neighbors_dict[\"1\"] -> ['2','3','4']\n",
    "+ members: 所有的member"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "network1 = sc.textFile(\"C:\\\\Users\\\\admin\\\\ucidata-zachary.edges.txt\",2).map(lambda x: x.split(\",\"))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "network2 = network1.map(lambda x:(x[1],x[0]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "network = network1.union(network2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "neighbors = network.groupByKey().map(lambda x: (x[0], list(x[1])))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[('4', ['8', '13', '14', '1', '2', '3'])]"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "neighbors.take(1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "neighbors_dict = dict(neighbors.collect())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['2',\n",
       " '3',\n",
       " '4',\n",
       " '5',\n",
       " '6',\n",
       " '7',\n",
       " '8',\n",
       " '9',\n",
       " '11',\n",
       " '12',\n",
       " '13',\n",
       " '14',\n",
       " '18',\n",
       " '20',\n",
       " '22',\n",
       " '32']"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "neighbors_dict[\"1\"]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "member = neighbors.map(lambda x:x[0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['4',\n",
       " '24',\n",
       " '26',\n",
       " '16',\n",
       " '10',\n",
       " '20',\n",
       " '12',\n",
       " '3',\n",
       " '6',\n",
       " '7',\n",
       " '25',\n",
       " '15',\n",
       " '23',\n",
       " '30',\n",
       " '31',\n",
       " '32',\n",
       " '18',\n",
       " '1',\n",
       " '9',\n",
       " '29',\n",
       " '19',\n",
       " '21',\n",
       " '14',\n",
       " '33',\n",
       " '8',\n",
       " '17',\n",
       " '22',\n",
       " '34',\n",
       " '2',\n",
       " '5',\n",
       " '27',\n",
       " '28',\n",
       " '11',\n",
       " '13']"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "member.cache().collect()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "# all members\n",
    "members = member.collect()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 2. Implement Girvan Newman Algorithm "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## (1) Implement Depth-First-Search"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "def find_path(x):\n",
    "    \n",
    "    # x裡面的members有沒有\"全\"在目前為止path上的所有members中\n",
    "    def all_in_all_element(x):\n",
    "        boolean = True\n",
    "        for c in x:\n",
    "            if c in all_element:\n",
    "                continue\n",
    "            else:\n",
    "                boolean = False\n",
    "                break\n",
    "        return boolean\n",
    "    \n",
    "    #第一層:root本身\n",
    "    all_element = []\n",
    "    all_element.append(x)\n",
    "    path = []\n",
    "    path.append([x])\n",
    "    \n",
    "    \n",
    "    # 第二層\n",
    "    level_2 = []\n",
    "    for c in neighbors_dict[x]:\n",
    "        if c not in all_element:\n",
    "            level_2.append(c)\n",
    "            all_element.append(c)\n",
    "    path.append(level_2)\n",
    "    \n",
    "    #持續好幾層，直到找不到為止\n",
    "    while path[-1] != []:\n",
    "        level = []\n",
    "        for c in level_2:\n",
    "            if  all_in_all_element(neighbors_dict[c]) == False:\n",
    "                for k in neighbors_dict[c]:\n",
    "                    if k not in all_element:\n",
    "                        level.append(k)\n",
    "                        all_element.append(k)\n",
    "        path.append(level)\n",
    "        level_2 = level\n",
    "\n",
    "    return path"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## (2) 找出每個edge的betweenness score"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "def find_betweenness(x): # ex. find_betweenness(\"56\")\n",
    "    \n",
    "    # 在find_path(\"56\")中，逐層計算steps\n",
    "    steps = {}\n",
    "    for c in find_path(x)[0]:\n",
    "        steps.update({c:1})\n",
    "    for c in find_path(x)[1]:\n",
    "        steps.update({c:1})\n",
    "    for i in range(2,len(find_path(x))):\n",
    "        for c in find_path(x)[i]:\n",
    "            count = 0\n",
    "            for k in find_path(x)[i-1]:\n",
    "                if k in neighbors_dict[c]:\n",
    "                    count += steps[k]\n",
    "            steps.update({c:count})\n",
    "            \n",
    "    # 為了方便後續計算，再用find_path找出path中每一個member的直系上一層(parent)\n",
    "    # family -> 所有member與它的parent的dictionary\n",
    "    family = {}\n",
    "    i = 0\n",
    "    while i+1 < len(find_path(x)):\n",
    "        for c in find_path(x)[i+1]:\n",
    "            parent = []\n",
    "            for k in find_path(x)[i]:\n",
    "                if k in neighbors_dict[c]:\n",
    "                    parent.append(k)\n",
    "            family.update({c:parent})\n",
    "        i += 1\n",
    "    \n",
    "    \n",
    "    # 計算在path上的所有edge的betweenness score\n",
    "    edge = {}\n",
    "    betweenness_score = {}\n",
    "    for c in find_path(x):\n",
    "        for k in c:\n",
    "            edge.update({k:1})\n",
    "    i = len(find_path(x))-1\n",
    "    while i > 0:\n",
    "        for c in find_path(x)[i]:\n",
    "            for k in family[c]:\n",
    "                betweenness_score.update({(k,c):edge[c]*(steps[k]/steps[c])})\n",
    "                edge.update({k:edge[k]+edge[c]*(steps[k]/steps[c])})\n",
    "        i -= 1\n",
    "    \n",
    "    # 為了方便後續計算，將edge的表示方式調整成('34/15')且前面的數字一定比後面的大\n",
    "    betweenness_score_list = []\n",
    "    for c in betweenness_score:\n",
    "        bigger = max(eval(c[0]),eval(c[1]))\n",
    "        smaller = min(eval(c[0]),eval(c[1]))\n",
    "        edge_id = str(bigger)+\"/\"+str(smaller)\n",
    "        betweenness_score_list.append((edge_id,betweenness_score[c]))\n",
    "    \n",
    "    \n",
    "    \n",
    "    return betweenness_score_list"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "運用RDD將所有重複的edge的score加總並從大排到小排序"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "betweenness_scores = member.flatMap(find_betweenness) #找出每個edge的betweenness"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[('34/15', 0.5)]"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "betweenness_scores.take(1)  #[('34/15', 0.5)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "betweenness_reduce = betweenness_scores.reduceByKey(lambda x,y: x+y) #重複的edge的score加起來"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[('34/15', 38.977777777777774)]"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "betweenness_reduce.take(1)  #[('34/15', 38.977777777777774)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "reduce_sort = betweenness_reduce.sortBy(lambda x: x[1],False) #排序"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[('32/1', 142.78571428571428)]"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "reduce_sort.take(1)  #('32/1', 142.78571428571428)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[('32/1', 142.78571428571428),\n",
       " ('7/1', 87.66666666666666),\n",
       " ('6/1', 87.66666666666666),\n",
       " ('3/1', 87.27777777777779),\n",
       " ('9/1', 83.2968253968254),\n",
       " ('33/3', 77.40317460317459),\n",
       " ('34/14', 76.0984126984127),\n",
       " ('34/20', 66.62698412698413),\n",
       " ('12/1', 66.0),\n",
       " ('34/27', 60.91428571428571),\n",
       " ('34/32', 59.907936507936505),\n",
       " ('5/1', 58.66666666666666),\n",
       " ('11/1', 58.66666666666666),\n",
       " ('13/1', 52.2),\n",
       " ('20/1', 51.54126984126984),\n",
       " ('14/1', 47.54126984126984),\n",
       " ('32/26', 47.1888888888889),\n",
       " ('33/32', 46.48888888888889),\n",
       " ('28/3', 46.21746031746032),\n",
       " ('34/9', 45.369841269841274),\n",
       " ('18/1', 45.01904761904762),\n",
       " ('22/1', 45.01904761904762),\n",
       " ('32/25', 45.0),\n",
       " ('34/15', 38.977777777777774),\n",
       " ('34/16', 38.977777777777774),\n",
       " ('34/23', 38.977777777777774),\n",
       " ('34/19', 38.977777777777774),\n",
       " ('34/21', 38.977777777777774),\n",
       " ('34/24', 36.65555555555555),\n",
       " ('31/2', 36.219047619047615),\n",
       " ('10/3', 34.56190476190476),\n",
       " ('34/28', 34.195238095238096),\n",
       " ('33/9', 34.15555555555555),\n",
       " ('34/30', 33.44444444444444),\n",
       " ('34/10', 33.228571428571435),\n",
       " ('17/6', 33.0),\n",
       " ('17/7', 33.0),\n",
       " ('34/31', 30.085714285714285),\n",
       " ('2/1', 28.33333333333333),\n",
       " ('8/3', 28.290476190476184),\n",
       " ('34/29', 27.56190476190476),\n",
       " ('33/21', 27.022222222222226),\n",
       " ('33/15', 27.022222222222226),\n",
       " ('33/16', 27.022222222222226),\n",
       " ('33/19', 27.022222222222226),\n",
       " ('33/23', 27.022222222222226),\n",
       " ('33/30', 26.174603174603178),\n",
       " ('3/2', 26.066666666666666),\n",
       " ('8/1', 25.6047619047619),\n",
       " ('29/3', 25.56190476190476),\n",
       " ('4/3', 25.166666666666668),\n",
       " ('33/24', 25.066666666666666),\n",
       " ('4/1', 23.0),\n",
       " ('26/24', 22.18888888888889),\n",
       " ('22/2', 20.980952380952377),\n",
       " ('18/2', 20.980952380952377),\n",
       " ('28/25', 20.933333333333337),\n",
       " ('33/31', 19.133333333333333),\n",
       " ('14/4', 16.742857142857144),\n",
       " ('32/29', 16.666666666666664),\n",
       " ('20/2', 16.419047619047618),\n",
       " ('14/2', 13.919047619047618),\n",
       " ('13/4', 13.8),\n",
       " ('28/24', 11.82222222222222),\n",
       " ('31/9', 10.999999999999998),\n",
       " ('9/3', 10.295238095238094),\n",
       " ('34/33', 9.22857142857143),\n",
       " ('4/2', 8.666666666666666),\n",
       " ('14/3', 8.56190476190476),\n",
       " ('8/2', 8.32857142857143),\n",
       " ('30/24', 7.466666666666666),\n",
       " ('7/5', 5.333333333333334),\n",
       " ('11/6', 5.333333333333333),\n",
       " ('30/27', 5.085714285714285),\n",
       " ('26/25', 4.733333333333333),\n",
       " ('8/4', 3.776190476190476),\n",
       " ('11/5', 3.333333333333333),\n",
       " ('7/6', 3.333333333333333)]"
      ]
     },
     "execution_count": 19,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "reduce_sort.cache().collect()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## (3) 從betweenness score最高的edge開始斷開"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "cut_order = reduce_sort.map(lambda x: x[0].split(\"/\")) #總分不重要，只留下edge斷開的順序"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "degree = {c:len(neighbors_dict[c]) for c in neighbors_dict} #計算modularity需要知道每個member的degree"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [],
   "source": [
    "cut_order_list = cut_order.collect()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[['32', '1'],\n",
       " ['7', '1'],\n",
       " ['6', '1'],\n",
       " ['3', '1'],\n",
       " ['9', '1'],\n",
       " ['33', '3'],\n",
       " ['34', '14'],\n",
       " ['34', '20'],\n",
       " ['12', '1'],\n",
       " ['34', '27'],\n",
       " ['34', '32'],\n",
       " ['5', '1'],\n",
       " ['11', '1'],\n",
       " ['13', '1'],\n",
       " ['20', '1'],\n",
       " ['14', '1'],\n",
       " ['32', '26'],\n",
       " ['33', '32'],\n",
       " ['28', '3'],\n",
       " ['34', '9'],\n",
       " ['18', '1'],\n",
       " ['22', '1'],\n",
       " ['32', '25'],\n",
       " ['34', '15'],\n",
       " ['34', '16'],\n",
       " ['34', '23'],\n",
       " ['34', '19'],\n",
       " ['34', '21'],\n",
       " ['34', '24'],\n",
       " ['31', '2'],\n",
       " ['10', '3'],\n",
       " ['34', '28'],\n",
       " ['33', '9'],\n",
       " ['34', '30'],\n",
       " ['34', '10'],\n",
       " ['17', '6'],\n",
       " ['17', '7'],\n",
       " ['34', '31'],\n",
       " ['2', '1'],\n",
       " ['8', '3'],\n",
       " ['34', '29'],\n",
       " ['33', '21'],\n",
       " ['33', '15'],\n",
       " ['33', '16'],\n",
       " ['33', '19'],\n",
       " ['33', '23'],\n",
       " ['33', '30'],\n",
       " ['3', '2'],\n",
       " ['8', '1'],\n",
       " ['29', '3'],\n",
       " ['4', '3'],\n",
       " ['33', '24'],\n",
       " ['4', '1'],\n",
       " ['26', '24'],\n",
       " ['22', '2'],\n",
       " ['18', '2'],\n",
       " ['28', '25'],\n",
       " ['33', '31'],\n",
       " ['14', '4'],\n",
       " ['32', '29'],\n",
       " ['20', '2'],\n",
       " ['14', '2'],\n",
       " ['13', '4'],\n",
       " ['28', '24'],\n",
       " ['31', '9'],\n",
       " ['9', '3'],\n",
       " ['34', '33'],\n",
       " ['4', '2'],\n",
       " ['14', '3'],\n",
       " ['8', '2'],\n",
       " ['30', '24'],\n",
       " ['7', '5'],\n",
       " ['11', '6'],\n",
       " ['30', '27'],\n",
       " ['26', '25'],\n",
       " ['8', '4'],\n",
       " ['11', '5'],\n",
       " ['7', '6']]"
      ]
     },
     "execution_count": 23,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "cut_order_list #[(\"32\",\"1\"),...]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "import itertools"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## root&leaf\n",
    "+ root: 能用最少的路徑到達所有的點 -> 核心\n",
    "+ leaf: 其他不是核心的member"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "def find_root(x):\n",
    "    path_length = []\n",
    "    for c in x:\n",
    "        path_length.append(len(find_path(c)))\n",
    "    return min(path_length)        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "5"
      ]
     },
     "execution_count": 19,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "find_root(members) #最少路徑是5"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "root = [i for i in itertools.filterfalse(lambda x: len(find_path(x)) != 5, members)] #最核心的members -> 路徑長度5"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [],
   "source": [
    "leaf = [i for i in itertools.filterfalse(lambda x:x in root, members)] #核心member以外的人"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [],
   "source": [
    "neighbors_dict = dict(neighbors.collect())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[['32', '1'],\n",
       " ['7', '1'],\n",
       " ['6', '1'],\n",
       " ['3', '1'],\n",
       " ['9', '1'],\n",
       " ['33', '3'],\n",
       " ['34', '14'],\n",
       " ['34', '20'],\n",
       " ['12', '1'],\n",
       " ['34', '27'],\n",
       " ['34', '32'],\n",
       " ['5', '1'],\n",
       " ['11', '1'],\n",
       " ['13', '1'],\n",
       " ['20', '1'],\n",
       " ['14', '1'],\n",
       " ['32', '26'],\n",
       " ['33', '32'],\n",
       " ['28', '3'],\n",
       " ['34', '9'],\n",
       " ['18', '1'],\n",
       " ['22', '1'],\n",
       " ['32', '25'],\n",
       " ['34', '15'],\n",
       " ['34', '16'],\n",
       " ['34', '23'],\n",
       " ['34', '19'],\n",
       " ['34', '21'],\n",
       " ['34', '24'],\n",
       " ['31', '2'],\n",
       " ['10', '3'],\n",
       " ['34', '28'],\n",
       " ['33', '9'],\n",
       " ['34', '30'],\n",
       " ['34', '10'],\n",
       " ['17', '6'],\n",
       " ['17', '7'],\n",
       " ['34', '31'],\n",
       " ['2', '1'],\n",
       " ['8', '3'],\n",
       " ['34', '29'],\n",
       " ['33', '21'],\n",
       " ['33', '15'],\n",
       " ['33', '16'],\n",
       " ['33', '19'],\n",
       " ['33', '23'],\n",
       " ['33', '30'],\n",
       " ['3', '2'],\n",
       " ['8', '1'],\n",
       " ['29', '3'],\n",
       " ['4', '3'],\n",
       " ['33', '24'],\n",
       " ['4', '1'],\n",
       " ['26', '24'],\n",
       " ['22', '2'],\n",
       " ['18', '2'],\n",
       " ['28', '25'],\n",
       " ['33', '31'],\n",
       " ['14', '4'],\n",
       " ['32', '29'],\n",
       " ['20', '2'],\n",
       " ['14', '2'],\n",
       " ['13', '4'],\n",
       " ['28', '24'],\n",
       " ['31', '9'],\n",
       " ['9', '3'],\n",
       " ['34', '33'],\n",
       " ['4', '2'],\n",
       " ['14', '3'],\n",
       " ['8', '2'],\n",
       " ['30', '24'],\n",
       " ['7', '5'],\n",
       " ['11', '6'],\n",
       " ['30', '27'],\n",
       " ['26', '25'],\n",
       " ['8', '4'],\n",
       " ['11', '5'],\n",
       " ['7', '6']]"
      ]
     },
     "execution_count": 30,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "cut_order_list"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [],
   "source": [
    "winner_list = [[],0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "neighbors_dict_1 = dict(neighbors.collect())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "# group definitions / combinations\n",
    "winner_list = [[],0]\n",
    "winner_for_loop = []\n",
    "neighbors_dict = dict(neighbors.collect())\n",
    "Increased = False\n",
    "\n",
    "for f in range(10):\n",
    "    neighbors_dict = dict(neighbors.collect())\n",
    "    for c in cut_order_list:\n",
    "        all_element = []\n",
    "        a1 = c[0]\n",
    "        a2 = c[1]\n",
    "\n",
    "        neighbors_dict[c[0]].remove(c[1])\n",
    "        neighbors_dict[c[1]].remove(c[0])\n",
    "\n",
    "    ##找出graph中所有的components--------------------------------------------------------------------   \n",
    "        component = []\n",
    "\n",
    "        #找第一個component\n",
    "        for c in find_path(\"23\"): #\"23\"只是隨便一個數字，不管是任何數字應該都能找到同樣的結果\n",
    "            for k in c:\n",
    "                component.append(k)\n",
    "                all_element.append(k)\n",
    "        for c in component:\n",
    "            for k in neighbors_dict[c]:\n",
    "                if k not in component:\n",
    "                    component.append(k)\n",
    "                    all_element.append(k)\n",
    "\n",
    "\n",
    "\n",
    "        components = [component]\n",
    "\n",
    "\n",
    "        #找其他component\n",
    "        while len(set(members)) != len(set(all_element)):\n",
    "            candidate = [c for c in members if c not in all_element]\n",
    "            try:\n",
    "                component = []\n",
    "                for c in find_path(candidate[0]):\n",
    "                    for k in c:\n",
    "                        component.append(k)\n",
    "                        all_element.append(k)\n",
    "                components.append(component)\n",
    "            except:\n",
    "                pass\n",
    "\n",
    "    ##已斷開的edge連回去的條件--------------------------------------------------------------------------------\n",
    "        #不希望出現只有一個1個或2個的group被從大群裡面丟出來 <-> 定義一個group至少3人\n",
    "        Add_back = False\n",
    "        if any(len(c)<=2 for c in components) == True:  #如果出現這樣的情況則把edge連回去\n",
    "            neighbors_dict[a1] = list(itertools.chain(neighbors_dict[a1],[a2]))\n",
    "            neighbors_dict[a2] = list(itertools.chain(neighbors_dict[a2],[a1]))\n",
    "            Add_back = True\n",
    "\n",
    "        if  Add_back == True:\n",
    "            pass\n",
    "        else:\n",
    "\n",
    "    ##計算modularity------------------------------------------------------------------------------------------ \n",
    "            M = 0  #graph中edge的總量\n",
    "            Q = 0  #modularity\n",
    "\n",
    "            #先算M(graph中edge的總量)\n",
    "            for i in members:\n",
    "                M += degree[i]\n",
    "            #再算Q\n",
    "            for c in components:\n",
    "                #同一個group裡面兩個兩個加值到Q\n",
    "                for k in list(itertools.combinations(c , 2)):\n",
    "                    if k[1] in neighbors_dict_1[k[0]]:\n",
    "                        Q += 1-degree[k[1]]*degree[k[0]]/(2*M)\n",
    "                    else:\n",
    "                        Q += -degree[k[1]]*degree[k[0]]/(2*M)\n",
    "\n",
    "\n",
    "    ##將現有的component重組看看，可能可以得到更好的modularity---------------------------------------------\n",
    "\n",
    "            if len(components) == 1:   #只有一個group的時候就沒有組合的可能\n",
    "                pass\n",
    "            else:\n",
    "                Q_list_c = []\n",
    "                combination_list = []\n",
    "                for c in list(itertools.combinations(components , 2)):\n",
    "                    combinations = []\n",
    "                    new_component = list(itertools.chain(c[0],c[1]))\n",
    "                    another = [c for c in itertools.filterfalse(lambda x: x in new_component, members)]\n",
    "                    combinations.append(new_component)\n",
    "                    combinations.append(another)\n",
    "                    combination_list.append(combinations)\n",
    "\n",
    "                    Q_c = 0\n",
    "\n",
    "                    for c in combinations:\n",
    "                        for k in list(itertools.combinations(c,2)):\n",
    "                            if k[1] in neighbors_dict_1[k[0]]:\n",
    "\n",
    "                                Q_c += 1-degree[k[1]]*degree[k[0]]/(2*M)\n",
    "                            else:\n",
    "                                Q_c += -degree[k[1]]*degree[k[0]]/(2*M)\n",
    "\n",
    "\n",
    "                    Q_list_c.append(Q_c)\n",
    "                #在所有組合中擁有最大Q值的組合被留下來\n",
    "                winner_combination = [combination_list[Q_list_c.index(max(Q_list_c))],max(Q_list_c)/(2*M)]\n",
    "    #                 print(winner_combination)\n",
    "    ##來比較一下吧------------------------------------------------------------------------------------------\n",
    "            if len(components) != 1:  #只有一個group的時候，沒有組合 ->會出現ERROR\n",
    "                #把這次切斷所形成的graph和最大Q組合的graph以及在上一個loop中擁有最大Q的衛冕者做比較\n",
    "                challengers = [Q/(2*M), winner_list[1], winner_combination[1]]\n",
    "                support = [\"components\",\"winner_list[0]\", \"winner_combination[0]\"]\n",
    "\n",
    "\n",
    "            if len(components) < int(f):  #由於必須切割到一定程度，組合的Q才會開始有組合效益\n",
    "                pass\n",
    "            else:\n",
    "                if Q/(2*M) > winner_list[1]:\n",
    "                    winner_list[0] = components\n",
    "                    winner_list[1] = Q/(2*M)\n",
    "                    \n",
    "\n",
    "                else:\n",
    "                    neighbors_dict[a1] = list(itertools.chain(neighbors_dict[a1],[a2]))\n",
    "                    neighbors_dict[a2] = list(itertools.chain(neighbors_dict[a2],[a1]))\n",
    "                    Add_back = True\n",
    "\n",
    "                if len(components) != 1:\n",
    "                    ##最後留下來的就是那次loop勝出的衛冕者\n",
    "                    winner_list[0] = eval(support[challengers.index(max(challengers))])\n",
    "                    winner_list[1] = max(challengers)\n",
    "##for loop 什麼時候停\n",
    "    winner_for_loop.append(winner_list[1])\n",
    "    try:\n",
    "        if Increased == True:\n",
    "            if winner_for_loop[-1] == winner_for_loop[-2]:\n",
    "                break\n",
    "        if winner_for_loop[-1] > winner_for_loop[-2]:\n",
    "            Increased = True\n",
    "        \n",
    "    except:\n",
    "        pass\n",
    "    \n",
    "                                    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[[['23',\n",
       "   '33',\n",
       "   '21',\n",
       "   '15',\n",
       "   '16',\n",
       "   '19',\n",
       "   '31',\n",
       "   '34',\n",
       "   '9',\n",
       "   '10',\n",
       "   '3',\n",
       "   '29',\n",
       "   '32',\n",
       "   '24',\n",
       "   '30',\n",
       "   '28',\n",
       "   '27',\n",
       "   '25',\n",
       "   '26'],\n",
       "  ['4',\n",
       "   '20',\n",
       "   '12',\n",
       "   '6',\n",
       "   '7',\n",
       "   '18',\n",
       "   '1',\n",
       "   '14',\n",
       "   '8',\n",
       "   '17',\n",
       "   '22',\n",
       "   '2',\n",
       "   '5',\n",
       "   '11',\n",
       "   '13']],\n",
       " 0.16019477317554234]"
      ]
     },
     "execution_count": 62,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "list(winner_list)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "#demo1 - no group definition / combinations\n",
    "winner_list_1 = [[],0]\n",
    "winner_for_loop_1 = []\n",
    "neighbors_dict = dict(neighbors.collect())\n",
    "Increased = False\n",
    "\n",
    "for f in range(10):\n",
    "    neighbors_dict = dict(neighbors.collect())\n",
    "    for c in cut_order_list:\n",
    "        all_element = []\n",
    "        a1 = c[0]\n",
    "        a2 = c[1]\n",
    "\n",
    "    \n",
    "        neighbors_dict[c[0]].remove(c[1])\n",
    "        neighbors_dict[c[1]].remove(c[0])\n",
    "\n",
    "    ##找出graph中所有的components--------------------------------------------------------------------   \n",
    "        component = []\n",
    "\n",
    "        #找第一個component\n",
    "        for c in find_path(\"23\"): #\"23\"只是隨便一個數字，不管是任何數字應該都能找到同樣的結果\n",
    "            for k in c:\n",
    "                component.append(k)\n",
    "                all_element.append(k)\n",
    "        for c in component:\n",
    "            for k in neighbors_dict[c]:\n",
    "                if k not in component:\n",
    "                    component.append(k)\n",
    "                    all_element.append(k)\n",
    "\n",
    "\n",
    "\n",
    "        components = [component]\n",
    "\n",
    "\n",
    "        #找其他component\n",
    "        while len(set(members)) != len(set(all_element)):\n",
    "            candidate = [c for c in members if c not in all_element]\n",
    "            try:\n",
    "                component = []\n",
    "                for c in find_path(candidate[0]):\n",
    "                    for k in c:\n",
    "                        component.append(k)\n",
    "                        all_element.append(k)\n",
    "                components.append(component)\n",
    "            except:\n",
    "                pass\n",
    "\n",
    "    ##已斷開的edge連回去的條件--------------------------------------------------------------------------- Problem 2\n",
    "        #不希望出現只有一個1個或2個的group被從大群裡面丟出來 <-> 定義一個group至少3人\n",
    "#         Add_back = False\n",
    "#         if any(len(c)<=2 for c in components) == True:  #如果出現這樣的情況則把edge連回去\n",
    "#             neighbors_dict[a1] = list(itertools.chain(neighbors_dict[a1],[a2]))\n",
    "#             neighbors_dict[a2] = list(itertools.chain(neighbors_dict[a2],[a1]))\n",
    "#             Add_back = True\n",
    "\n",
    "#         if  Add_back == True:\n",
    "#             pass\n",
    "        if 1+1 != 2:\n",
    "            pass\n",
    "        else:\n",
    "\n",
    "    ##計算modularity------------------------------------------------------------------------------------------ \n",
    "            M = 0  #graph中edge的總量\n",
    "            Q = 0  #modularity\n",
    "\n",
    "            #先算M(graph中edge的總量)\n",
    "            for i in members:\n",
    "                M += degree[i]\n",
    "            #再算Q\n",
    "            for c in components:\n",
    "                #同一個group裡面兩個兩個加值到Q\n",
    "                for k in list(itertools.combinations(c , 2)):\n",
    "                    if k[1] in neighbors_dict_1[k[0]]:\n",
    "                        Q += 1-degree[k[1]]*degree[k[0]]/(2*M)\n",
    "                    else:\n",
    "                        Q += -degree[k[1]]*degree[k[0]]/(2*M)\n",
    "\n",
    "\n",
    "    ##將現有的component重組看看，可能可以得到更好的modularity---------------------------------------------   for the best Q\n",
    "\n",
    "            if len(components) == 1:   #只有一個group的時候就沒有組合的可能\n",
    "                pass\n",
    "            else:\n",
    "                Q_list_c = []\n",
    "                combination_list = []\n",
    "                for c in list(itertools.combinations(components , 2)):\n",
    "                    combinations = []\n",
    "                    new_component = list(itertools.chain(c[0],c[1]))\n",
    "                    another = [c for c in itertools.filterfalse(lambda x: x in new_component, members)]\n",
    "                    combinations.append(new_component)\n",
    "                    combinations.append(another)\n",
    "                    combination_list.append(combinations)\n",
    "\n",
    "                    Q_c = 0\n",
    "\n",
    "                    for c in combinations:\n",
    "                        for k in list(itertools.combinations(c,2)):\n",
    "                            if k[1] in neighbors_dict_1[k[0]]:\n",
    "\n",
    "                                Q_c += 1-degree[k[1]]*degree[k[0]]/(2*M)\n",
    "                            else:\n",
    "                                Q_c += -degree[k[1]]*degree[k[0]]/(2*M)\n",
    "\n",
    "\n",
    "                    Q_list_c.append(Q_c)\n",
    "                #在所有組合中擁有最大Q值的組合被留下來\n",
    "                winner_combination = [combination_list[Q_list_c.index(max(Q_list_c))],max(Q_list_c)/(2*M)]\n",
    "    #                 print(winner_combination)\n",
    "    ##來比較一下吧------------------------------------------------------------------------------------------\n",
    "            if len(components) != 1:  #只有一個group的時候，沒有組合 ->會出現ERROR\n",
    "                #把這次切斷所形成的graph和最大Q組合的graph以及在上一個loop中擁有最大Q的衛冕者做比較\n",
    "                challengers = [Q/(2*M), winner_list[1], winner_combination[1]]\n",
    "                support = [\"components\",\"winner_list[0]\", \"winner_combination[0]\"]\n",
    "\n",
    "\n",
    "            if len(components) < int(f):  #由於必須切割到一定程度，組合的Q才會開始有組合效益\n",
    "                pass\n",
    "            else:\n",
    "                if Q/(2*M) > winner_list_1[1]:\n",
    "                    winner_list_1[0] = components\n",
    "                    winner_list_1[1] = Q/(2*M)\n",
    "\n",
    "                else:\n",
    "                    neighbors_dict[a1] = list(itertools.chain(neighbors_dict[a1],[a2]))\n",
    "                    neighbors_dict[a2] = list(itertools.chain(neighbors_dict[a2],[a1]))\n",
    "\n",
    "                if len(components) != 1:\n",
    "                    ##最後留下來的就是那次loop勝出的衛冕者\n",
    "                    winner_list[0] = eval(support[challengers.index(max(challengers))])\n",
    "                    winner_list[1] = max(challengers)\n",
    "##for loop 什麼時候停\n",
    "    winner_for_loop_1.append(winner_list_1[1])\n",
    "    try:\n",
    "        if Increased == True:\n",
    "            if winner_for_loop_1[-1] == winner_for_loop_1[-2]:\n",
    "                break\n",
    "        if winner_for_loop_1[-1] > winner_for_loop_1[-2]:\n",
    "            Increased = True\n",
    "        \n",
    "    except:\n",
    "        pass\n",
    "    \n",
    "                                    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[[['23',\n",
       "   '33',\n",
       "   '21',\n",
       "   '15',\n",
       "   '16',\n",
       "   '19',\n",
       "   '24',\n",
       "   '31',\n",
       "   '34',\n",
       "   '30',\n",
       "   '28',\n",
       "   '9',\n",
       "   '27',\n",
       "   '25',\n",
       "   '3',\n",
       "   '26',\n",
       "   '29',\n",
       "   '32'],\n",
       "  ['4', '8', '1', '13', '2', '22', '18', '20', '14'],\n",
       "  ['10'],\n",
       "  ['12'],\n",
       "  ['6', '7', '11', '5', '17']],\n",
       " 0.14828854372123593]"
      ]
     },
     "execution_count": 55,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "list(winner_list_1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "metadata": {},
   "outputs": [],
   "source": [
    "#demo2 - group definations / no combinations\n",
    "winner_list_1 = [[],0]\n",
    "winner_for_loop_1 = []\n",
    "neighbors_dict = dict(neighbors.collect())\n",
    "Increased = False\n",
    "\n",
    "for f in range(10):\n",
    "    neighbors_dict = dict(neighbors.collect())\n",
    "    for c in cut_order_list:\n",
    "        all_element = []\n",
    "        a1 = c[0]\n",
    "        a2 = c[1]\n",
    "\n",
    "    \n",
    "        neighbors_dict[c[0]].remove(c[1])\n",
    "        neighbors_dict[c[1]].remove(c[0])\n",
    "\n",
    "    ##找出graph中所有的components--------------------------------------------------------------------   \n",
    "        component = []\n",
    "\n",
    "        #找第一個component\n",
    "        for c in find_path(\"23\"): #\"23\"只是隨便一個數字，不管是任何數字應該都能找到同樣的結果\n",
    "            for k in c:\n",
    "                component.append(k)\n",
    "                all_element.append(k)\n",
    "        for c in component:\n",
    "            for k in neighbors_dict[c]:\n",
    "                if k not in component:\n",
    "                    component.append(k)\n",
    "                    all_element.append(k)\n",
    "\n",
    "\n",
    "\n",
    "        components = [component]\n",
    "\n",
    "\n",
    "        #找其他component\n",
    "        while len(set(members)) != len(set(all_element)):\n",
    "            candidate = [c for c in members if c not in all_element]\n",
    "            try:\n",
    "                component = []\n",
    "                for c in find_path(candidate[0]):\n",
    "                    for k in c:\n",
    "                        component.append(k)\n",
    "                        all_element.append(k)\n",
    "                components.append(component)\n",
    "            except:\n",
    "                pass\n",
    "\n",
    "    ##已斷開的edge連回去的條件--------------------------------------------------------------------------- Problem 2\n",
    "        #不希望出現只有一個1個或2個的group被從大群裡面丟出來 <-> 定義一個group至少3人\n",
    "        Add_back = False\n",
    "        if any(len(c)<=2 for c in components) == True:  #如果出現這樣的情況則把edge連回去\n",
    "            neighbors_dict[a1] = list(itertools.chain(neighbors_dict[a1],[a2]))\n",
    "            neighbors_dict[a2] = list(itertools.chain(neighbors_dict[a2],[a1]))\n",
    "            Add_back = True\n",
    "\n",
    "        if  Add_back == True:\n",
    "            pass\n",
    "        else:\n",
    "\n",
    "    ##計算modularity------------------------------------------------------------------------------------------ \n",
    "            M = 0  #graph中edge的總量\n",
    "            Q = 0  #modularity\n",
    "\n",
    "            #先算M(graph中edge的總量)\n",
    "            for i in members:\n",
    "                M += degree[i]\n",
    "            #再算Q\n",
    "            for c in components:\n",
    "                #同一個group裡面兩個兩個加值到Q\n",
    "                for k in list(itertools.combinations(c , 2)):\n",
    "                    if k[1] in neighbors_dict_1[k[0]]:\n",
    "                        Q += 1-degree[k[1]]*degree[k[0]]/(2*M)\n",
    "                    else:\n",
    "                        Q += -degree[k[1]]*degree[k[0]]/(2*M)\n",
    "\n",
    "\n",
    "    ##將現有的component重組看看，可能可以得到更好的modularity---------------------------------------------   for the best Q\n",
    "\n",
    "#             if len(components) == 1:   #只有一個group的時候就沒有組合的可能\n",
    "#                 pass\n",
    "#             else:\n",
    "#                 Q_list_c = []\n",
    "#                 combination_list = []\n",
    "#                 for c in list(itertools.combinations(components , 2)):\n",
    "#                     combinations = []\n",
    "#                     new_component = list(itertools.chain(c[0],c[1]))\n",
    "#                     another = [c for c in itertools.filterfalse(lambda x: x in new_component, members)]\n",
    "#                     combinations.append(new_component)\n",
    "#                     combinations.append(another)\n",
    "#                     combination_list.append(combinations)\n",
    "\n",
    "#                     Q_c = 0\n",
    "\n",
    "#                     for c in combinations:\n",
    "#                         for k in list(itertools.combinations(c,2)):\n",
    "#                             if k[1] in neighbors_dict_1[k[0]]:\n",
    "\n",
    "#                                 Q_c += 1-degree[k[1]]*degree[k[0]]/(2*M)\n",
    "#                             else:\n",
    "#                                 Q_c += -degree[k[1]]*degree[k[0]]/(2*M)\n",
    "\n",
    "\n",
    "#                     Q_list_c.append(Q_c)\n",
    "#                 #在所有組合中擁有最大Q值的組合被留下來\n",
    "#                 winner_combination = [combination_list[Q_list_c.index(max(Q_list_c))],max(Q_list_c)/(2*M)]\n",
    "#     #                 print(winner_combination)\n",
    "#     ##來比較一下吧------------------------------------------------------------------------------------------\n",
    "#             if len(components) != 1:  #只有一個group的時候，沒有組合 ->會出現ERROR\n",
    "#                 #把這次切斷所形成的graph和最大Q組合的graph以及在上一個loop中擁有最大Q的衛冕者做比較\n",
    "#                 challengers = [Q/(2*M), winner_list[1], winner_combination[1]]\n",
    "#                 support = [\"components\",\"winner_list[0]\", \"winner_combination[0]\"]\n",
    "\n",
    "\n",
    "            if len(components) < int(f):  #由於必須切割到一定程度，組合的Q才會開始有組合效益\n",
    "                pass\n",
    "            else:\n",
    "                if Q/(2*M) > winner_list_1[1]:\n",
    "                    winner_list_1[0] = components\n",
    "                    winner_list_1[1] = Q/(2*M)\n",
    "\n",
    "                else:\n",
    "                    neighbors_dict[a1] = list(itertools.chain(neighbors_dict[a1],[a2]))\n",
    "                    neighbors_dict[a2] = list(itertools.chain(neighbors_dict[a2],[a1]))\n",
    "\n",
    "#                 if len(components) != 1:\n",
    "#                     ##最後留下來的就是那次loop勝出的衛冕者\n",
    "#                     winner_list[0] = eval(support[challengers.index(max(challengers))])\n",
    "#                     winner_list[1] = max(challengers)\n",
    "##for loop 什麼時候停\n",
    "    winner_for_loop_1.append(winner_list_1[1])\n",
    "    try:\n",
    "        if Increased == True:\n",
    "            if winner_for_loop_1[-1] == winner_for_loop_1[-2]:\n",
    "                break\n",
    "        if winner_for_loop_1[-1] > winner_for_loop_1[-2]:\n",
    "            Increased = True\n",
    "        \n",
    "    except:\n",
    "        pass\n",
    "    \n",
    "                                    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[[['23',\n",
       "   '33',\n",
       "   '21',\n",
       "   '15',\n",
       "   '16',\n",
       "   '19',\n",
       "   '24',\n",
       "   '34',\n",
       "   '30',\n",
       "   '28',\n",
       "   '10',\n",
       "   '27',\n",
       "   '25',\n",
       "   '26'],\n",
       "  ['4',\n",
       "   '8',\n",
       "   '1',\n",
       "   '14',\n",
       "   '13',\n",
       "   '2',\n",
       "   '12',\n",
       "   '3',\n",
       "   '22',\n",
       "   '18',\n",
       "   '20',\n",
       "   '29',\n",
       "   '9',\n",
       "   '32',\n",
       "   '31'],\n",
       "  ['6', '7', '11', '5', '17']],\n",
       " 0.14622370151216302]"
      ]
     },
     "execution_count": 58,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "list(winner_list_1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "metadata": {},
   "outputs": [],
   "source": [
    "#demo2 - no group definitions / no combinations\n",
    "winner_list_1 = [[],0]\n",
    "winner_for_loop_1 = []\n",
    "neighbors_dict = dict(neighbors.collect())\n",
    "Increased = False\n",
    "\n",
    "for f in range(10):\n",
    "    neighbors_dict = dict(neighbors.collect())\n",
    "    for c in cut_order_list:\n",
    "        all_element = []\n",
    "        a1 = c[0]\n",
    "        a2 = c[1]\n",
    "\n",
    "    \n",
    "        neighbors_dict[c[0]].remove(c[1])\n",
    "        neighbors_dict[c[1]].remove(c[0])\n",
    "\n",
    "    ##找出graph中所有的components--------------------------------------------------------------------   \n",
    "        component = []\n",
    "\n",
    "        #找第一個component\n",
    "        for c in find_path(\"23\"): #\"23\"只是隨便一個數字，不管是任何數字應該都能找到同樣的結果\n",
    "            for k in c:\n",
    "                component.append(k)\n",
    "                all_element.append(k)\n",
    "        for c in component:\n",
    "            for k in neighbors_dict[c]:\n",
    "                if k not in component:\n",
    "                    component.append(k)\n",
    "                    all_element.append(k)\n",
    "\n",
    "\n",
    "\n",
    "        components = [component]\n",
    "\n",
    "\n",
    "        #找其他component\n",
    "        while len(set(members)) != len(set(all_element)):\n",
    "            candidate = [c for c in members if c not in all_element]\n",
    "            try:\n",
    "                component = []\n",
    "                for c in find_path(candidate[0]):\n",
    "                    for k in c:\n",
    "                        component.append(k)\n",
    "                        all_element.append(k)\n",
    "                components.append(component)\n",
    "            except:\n",
    "                pass\n",
    "\n",
    "    ##已斷開的edge連回去的條件--------------------------------------------------------------------------- Problem 2\n",
    "        #不希望出現只有一個1個或2個的group被從大群裡面丟出來 <-> 定義一個group至少3人\n",
    "#         Add_back = False\n",
    "#         if any(len(c)<=2 for c in components) == True:  #如果出現這樣的情況則把edge連回去\n",
    "#             neighbors_dict[a1] = list(itertools.chain(neighbors_dict[a1],[a2]))\n",
    "#             neighbors_dict[a2] = list(itertools.chain(neighbors_dict[a2],[a1]))\n",
    "#             Add_back = True\n",
    "\n",
    "#         if  Add_back == True:\n",
    "#             pass\n",
    "        if 1+1 != 2:\n",
    "            pass\n",
    "        else:\n",
    "\n",
    "    ##計算modularity------------------------------------------------------------------------------------------ \n",
    "            M = 0  #graph中edge的總量\n",
    "            Q = 0  #modularity\n",
    "\n",
    "            #先算M(graph中edge的總量)\n",
    "            for i in members:\n",
    "                M += degree[i]\n",
    "            #再算Q\n",
    "            for c in components:\n",
    "                #同一個group裡面兩個兩個加值到Q\n",
    "                for k in list(itertools.combinations(c , 2)):\n",
    "                    if k[1] in neighbors_dict_1[k[0]]:\n",
    "                        Q += 1-degree[k[1]]*degree[k[0]]/(2*M)\n",
    "                    else:\n",
    "                        Q += -degree[k[1]]*degree[k[0]]/(2*M)\n",
    "\n",
    "\n",
    "    ##將現有的component重組看看，可能可以得到更好的modularity---------------------------------------------   for the best Q\n",
    "\n",
    "#             if len(components) == 1:   #只有一個group的時候就沒有組合的可能\n",
    "#                 pass\n",
    "#             else:\n",
    "#                 Q_list_c = []\n",
    "#                 combination_list = []\n",
    "#                 for c in list(itertools.combinations(components , 2)):\n",
    "#                     combinations = []\n",
    "#                     new_component = list(itertools.chain(c[0],c[1]))\n",
    "#                     another = [c for c in itertools.filterfalse(lambda x: x in new_component, members)]\n",
    "#                     combinations.append(new_component)\n",
    "#                     combinations.append(another)\n",
    "#                     combination_list.append(combinations)\n",
    "\n",
    "#                     Q_c = 0\n",
    "\n",
    "#                     for c in combinations:\n",
    "#                         for k in list(itertools.combinations(c,2)):\n",
    "#                             if k[1] in neighbors_dict_1[k[0]]:\n",
    "\n",
    "#                                 Q_c += 1-degree[k[1]]*degree[k[0]]/(2*M)\n",
    "#                             else:\n",
    "#                                 Q_c += -degree[k[1]]*degree[k[0]]/(2*M)\n",
    "\n",
    "\n",
    "#                     Q_list_c.append(Q_c)\n",
    "#                 #在所有組合中擁有最大Q值的組合被留下來\n",
    "#                 winner_combination = [combination_list[Q_list_c.index(max(Q_list_c))],max(Q_list_c)/(2*M)]\n",
    "#     #                 print(winner_combination)\n",
    "#     ##來比較一下吧------------------------------------------------------------------------------------------\n",
    "#             if len(components) != 1:  #只有一個group的時候，沒有組合 ->會出現ERROR\n",
    "#                 #把這次切斷所形成的graph和最大Q組合的graph以及在上一個loop中擁有最大Q的衛冕者做比較\n",
    "#                 challengers = [Q/(2*M), winner_list[1], winner_combination[1]]\n",
    "#                 support = [\"components\",\"winner_list[0]\", \"winner_combination[0]\"]\n",
    "\n",
    "\n",
    "            if len(components) < int(f):  #由於必須切割到一定程度，組合的Q才會開始有組合效益\n",
    "                pass\n",
    "            else:\n",
    "                if Q/(2*M) > winner_list_1[1]:\n",
    "                    winner_list_1[0] = components\n",
    "                    winner_list_1[1] = Q/(2*M)\n",
    "\n",
    "                else:\n",
    "                    neighbors_dict[a1] = list(itertools.chain(neighbors_dict[a1],[a2]))\n",
    "                    neighbors_dict[a2] = list(itertools.chain(neighbors_dict[a2],[a1]))\n",
    "\n",
    "#                 if len(components) != 1:\n",
    "#                     ##最後留下來的就是那次loop勝出的衛冕者\n",
    "#                     winner_list[0] = eval(support[challengers.index(max(challengers))])\n",
    "#                     winner_list[1] = max(challengers)\n",
    "##for loop 什麼時候停\n",
    "    winner_for_loop_1.append(winner_list_1[1])\n",
    "    try:\n",
    "        if Increased == True:\n",
    "            if winner_for_loop_1[-1] == winner_for_loop_1[-2]:\n",
    "                break\n",
    "        if winner_for_loop_1[-1] > winner_for_loop_1[-2]:\n",
    "            Increased = True\n",
    "        \n",
    "    except:\n",
    "        pass\n",
    "    \n",
    "                                    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[[['23',\n",
       "   '33',\n",
       "   '21',\n",
       "   '15',\n",
       "   '16',\n",
       "   '19',\n",
       "   '24',\n",
       "   '31',\n",
       "   '34',\n",
       "   '30',\n",
       "   '28',\n",
       "   '9',\n",
       "   '27',\n",
       "   '25',\n",
       "   '3',\n",
       "   '26',\n",
       "   '29',\n",
       "   '32'],\n",
       "  ['4', '8', '1', '13', '2', '22', '18', '20', '14'],\n",
       "  ['10'],\n",
       "  ['12'],\n",
       "  ['6', '7', '11', '5', '17']],\n",
       " 0.14828854372123593]"
      ]
     },
     "execution_count": 60,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "list(winner_list_1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[['23', '33', '15', '16', '19', '21', '31', '34', '9', '10', '3', '29', '32', '24', '30', '28', '27', '25', '26'], ['4', '20', '12', '6', '7', '18', '1', '14', '8', '17', '22', '2', '5', '11', '13']]\n",
      "0.16019477317554234\n"
     ]
    }
   ],
   "source": [
    "for c in winner_list:\n",
    "    print(c)\n",
    "    \n",
    "#最後做出的分群\n",
    "# [['4', '8', '1', '13', '2', '12', '22', '18', '20', '14', '6', '7', '11', '17', '5'], \n",
    "# ['24', '26', '16', '10', '3', '25', '15', '23', '30', '31', '32', '9', '29', '19', '21', '33', '34', '27', '28']]\n",
    "\n",
    "#最後的modularity\n",
    "# 0.16019477317554234"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {},
   "outputs": [],
   "source": [
    "import networkx as nx\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "metadata": {},
   "outputs": [],
   "source": [
    "G = nx.karate_club_graph()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "metadata": {},
   "outputs": [],
   "source": [
    "my_pos = nx.spring_layout(G, seed = 100)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "metadata": {},
   "outputs": [],
   "source": [
    "def tran(x):\n",
    "    new = []\n",
    "    for i in x:\n",
    "        com = []\n",
    "        for c in i:\n",
    "            com.append(eval(c)-1)\n",
    "        new.append(com)\n",
    "    return new"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 70,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[[3, 19, 11, 5, 6, 17, 0, 13, 7, 16, 21, 1, 4, 10, 12]]"
      ]
     },
     "execution_count": 70,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "tran([['4', '20', '12', '6', '7', '18', '1', '14', '8', '17', '22', '2', '5', '11', '13']])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 73,
   "metadata": {},
   "outputs": [],
   "source": [
    "# for node in G:\n",
    "#     if node in [11]:\n",
    "#         color_map.append('yellow')\n",
    "#     elif node in [2]:\n",
    "#         color_map.append(\"green\")\n",
    "#     else:\n",
    "#         color_map.append('red') \n",
    "color_map =[]\n",
    "for node in G:\n",
    "    if node in [3, 19, 11, 5, 6, 17, 0, 13, 7, 16, 21, 1, 4, 10, 12]:\n",
    "        color_map.append('orange')\n",
    "    else:\n",
    "        color_map.append(\"red\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 74,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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6N27N1euXGHr1q1UrVqVhQsXMnz4cJYtW0bjxo0B2Lt3L/3792fHjh24uLjk6hoODg4cO3bsldppwIABA3mFQZAN5JpHjx6xatUqgoODuXDhAm3btmXevHnUr18fozzIVLN27Vr69OlD165dWb58OcbGxgwZMoS1a9eyZ88eypdX/KIvXrxIu3btWLJkCZUrV871dQwWsgEDBt4kDIJsIEfExsayYcMGgoODCQkJwdvbmyFDhtC8eXNM8yJ9HfD06VP69evHgQMHWL16NfXr1yc6Opr27dvz9OlTDh06ROHCSnKMhw8f0rJlS3744Qc+/PDlImsZBNmAAQNvEoY5ZAOZkpyczNatW/H396do0aL89ttvtG3bllv/1969x+dc/38cf1y7djBbm9OIdNCJUSjSlyy+Vt/6Op9KiKFMMtHhGx2+fKWiiIpRin7KkshozhkmmtPCtE2lUCuHhs1strkOvz8+NRvbbHNd167seb/d3Hb4vD/vz2ty67n3+/P5vN+pqXz22Wd06dLFYWG8fv16mjZtir+/P3v27KFNmzakpqYSEhJCzZo1WbduXX4Y5+Tk0L17d3r16sXQoUPLfU0Fsoi4E63UJYXY7XZ27dpFVFQUixYt4tprr6V///706dOHq6++2uHX+2tDiOXLlzN37tz80e7OnTvp0aMHo0eP5tlnn81fLMRms9G/f39sNhsLFy68rCnys2fPUq1aNXJyci65GImIiLNpyloAY8GNvx7Ostvt9O/fn7i4OG699VanXTM+Pp6wsDDuvvtuEhMT85/CXrJkCcOHD+fDDz+kW7duhc4ZN24chw8fJjY29rLvV/v6+uLl5UVmZiYBAQGX1ZeIyOVSIFdix44dY9GiRSxYsIBffvmFPn36sGDBAu666y6njhgLbggxa9YsevbsCRij89dff53333+fdevWcccddxQ6b968eSxcuJBt27bh6+vrkFr+mrZWIItIRVMgVzKZmZn5ewtv376dLl26MHHiREJDQ/H0dP4/h4IbQuzdu5c6deoARkg//vjj7N+/n23btlGvXr1C561fv54XXniBzZs3F7vzU3n8Fcg33XSTw/oUESkPBXJFy0iGg1GQdQhsOeATBFeHQv3u4OF1ydNL49y5c6xdu5aoqChWr15NSEgIgwYNYunSpVQty76tl6HghhBTpkxh4MCB+aPwP/74gx49elC3bl3i4uIuqikpKYl+/fqxePHi/FeeHEUPdomIu1AgVwS7HX79ApImw+lkY69eu+X88UNRYBoKtzwJDUeBb50yX8Jms/HNN9/w6aef5gdZ//79mTFjBrVq1XLgD3NpBTeE2LVrF9ddd13+seTkZDp37ky/fv145ZVXLrovfPToUTp37sy0adNo166dw2tTIIuIu1Agu5o1D77pB7+vAWtW0W0sZ4yP+6fBgfchdANUb1aq7pOSkvL3Fvbz86N///7s3LmTG264wTH1l8GFG0KMGDGiUOCuXbuWAQMG8NZbbzFgwICLzs/OzqZr164MGjSIRx991Ck1KpBFxF0okF3JboOve8CxjWA9e+n2tlzIy4WvQuCBbRDYuMhmqampLFy4kKioKNLS0ujbty/Lli2jWbNmFfY6z4UbQlz4tHZkZCSvvvoqS5cupW3bthedb7VaefTRR2nUqBHjxo1zWp1BQUEcP37caf2LiJSWFgZxpe9ehWObShfGBVnOQGwHY3T9p/T0dObOnUuHDh1o2rQp33//PdOnT+fw4cNMmTKF5s2bV0gYF7UhRMEwtlgsjBw5ksjISLZu3VpkGAM8//zznDx5kg8++MCpP0dQUBBpaWlO619EpLQ0QnYVa54xBW3NLr6JDVq+DNdUhxX/KXjEDpZs8n7+jJhEP6KiooiNjeW+++4jIiKCjh07lmlvYWf5a0OIAwcO5G8IUVBGRgZ9+vTBbrcTHx9PYGBgkf3MmjWLlStXEh8fj4+Pj1Nr1pS1iLgLjZBdJTXamLIuwTtrILheMQctmexfOoTIyEg6d+7M4cOH+eKLL+jZs6dbhHF0dDTNmjWjYcOG7Nq166IwPnjwIG3atOHmm29m5cqVxYbxqlWrmDhxIqtWrSrX3sllpUAWEXehEbKrpEwFS2axh1NPwMo98FI3mLaq6Da3Xe/FhuhZENjISUWWXVEbQlxo69at9O7dm5deeomIiIhi+9qzZw+DBg1i+fLl3Hjjjc4sO58CWUTchUbIrnLmpxIPj/4E3uwLHiXcLvUw+0Dmjw4urPyK2hDiQgsWLKBHjx589NFHJYZxamoqXbp0ITIyktatWzuz7EIUyCLiLjRCdpUSHuRa8S3UDoQWDWBTcgl92K1w7rTjayuj4jaEKMhmszFu3DiioqLYuHEjTZo0Kba/zMxMOnfuzMiRI3nooYecWfpF/P39sVgsnD171mHLcYqIlIcC2VU8fMGaU+ShrT/Alwmwag/knIPTZ+HRWbDgyQsamjzA6yrn11qC4jaEKCg7O5uwsDB+//13tm/fTu3atYvtz2Kx0KdPH1q1asV//vOfYts5i8lkyh8lF1ywRETE1TRl7Sr+DYo9NOkRSJ0Jh96BzyKgQ+MiwhjAZoGrbnZejSXIzc3lxRdfpEePHkyePJlPPvmkyDA+cuQI7dq1o0qVKsTGxpYYxna7naeeegqr1UpkZGSFvTNdq1YtTVuLSIVTILtKo2fA8/JGt7+d9iX5NwfVUwaJiYm0atWK5ORk9u7dm78704X27NnD3XffTbdu3fj4448v+fT39OnT+frrr/n888/x8nLMut3lofvIIuIOFMiucl3vUjVr3/jCd5ANNrMf8RkhhIaG0qFDB5YsWcK5c+ccXGRhFouFSZMmERoaytNPP010dHT+7kwX+vLLL7n//vt56623ePnlly852o2OjmbatGklvgLlKgpkEXEHCmRXMftAw9FgLt/uSh6efvR++jMOHz5MeHg47777Lg0aNOCVV17hyJEjDi7W2BDi3nvvZf369SQkJDBo0KAiQ9ZutzN16lSGDx/OypUrS/VQ1o4dOwgPD2f58uVucd9WgSwi7kCB7Eq3j4egNmAu49O8nv7Q4Ssw++Dt7c0jjzzC5s2bWbVqFUeOHKFJkyb06dOHzZs3Y7fby19fehL2bY9x8pOr8V/fiNXDv2f9mDyus31TaNnOv+Tl5TF06FAWLFjAtm3baNWq1SUvcejQIbp3787cuXNp0aJF+Wt1IAWyiLgDBbIreZihXYyx37HZrxTtvcGrGoRuhOpNLzrctGlTZs+ezcGDBwkJCWHYsGH538vMLH4RkoscjYXVLbCtaYn1wDxqmI9RN9BGoPkkprQtsGMoLA2CPS/kPyl+8uRJHnjgAf744w+2bNnCtddee8nLpKen07FjR8aOHUvXrl1LX5+TKZBFxB0okF3NXAXuXQ6t3oPA2/6cwr7gP4Onv/EA2K0R0Ok7qNmyxC4DAwOJiIggOTmZd955h9jYWK6//vr875Xoh0jscV3g1Ld42HLwLOpfhOWM8f7z92/Duns4kLyTf/zjH7Rs2ZKlS5fi7+9/yR87Ly+PXr16cf/99/PUU09dsr0rKZBFxB2Y7Jc1xymX7eRuOPgJmceT2LVtC/988CFjBH3dQ0Z4l1Nqaipz5szhgw8+oFGjRowYMYJu3boVfpr55/nYdwzHZCv97lNWPPnuV/i25rsMfnx4qc6x2+089thjpKWlER0djdlsLuuP41Rbtmzh+eef55tvvqnoUkSkElMgu4lDhw7Rvn17Dh065NB+8/LyiI6OZtasWRw4cIDw8HDCw8OpG2jFsuwmPLn43vClWPHGHPw03DG5VO1fe+01li5dSlxcXKlG0672/fff07lzZ3780X2WJRWRykdT1m7C09MTi8Xi8H69vb3p06cPcXFxrFmzhmPHjtG4cWMiRzfBcu58GA+ZA7WHw21jzp978gzcPwluecb4eCrL+L6ZPDgwG6y5l7z+woULmTNnDjExMW4ZxqApaxFxDwpkN+GsQC7o9ttvp2fPnlQLqEpY6yyqFJi9HhQCa54v3H7ylxDaBH6cZnyc/GWBg3Y7/Lq0xOtt2bKFUaNGsWLFCurVK25fyYpXrVo1srKyyMsr+2yBiIijKJDdhKenp1MX+sjKyiIiIoLBgwfzReRw/P0Kvw99bzDUuGAAu/xbCAsxPg8LgWUJBQ5aMuGHGcVe78cff6R3794sWLCA22+/3UE/hXN4eHhQs2ZN0tLSKroUEanEFMhuwpkj5Pj4eO644w4yMjJITEzkzkZ1jJ2jLuFYBtT9c7nqutXheMYFDbKLXsfzxIkTdOzYkYkTJxa5E5Q70rS1iFQ07fbkJry8vBweyLm5uUyYMIF58+Yxa9as82tQH88pVSBfku3ie8g5OTl0796dnj17MnTo0Mu/hosokEWkoimQ3YSjR8iJiYkMGDCABg0asHfv3sJrUHsFgskTKPmhrDqBcOSUMTo+csrYs7lw0YU3y7Db7QwZMoS6desyadIkx/wgLqJAFpGKpilrN+GoQC7VhhA17gRsl+yr650w/2vj8/lfQ7c7Cxw0maFW60Ltx40bx8GDB5k/fz4eHn+vf1pBQUG6hywiFUojZDfh4eGBzWbDZrOVO8x+/PFHwsLC8PX1JSEhofiNG6rdBlc1hPQ9+d/qOxM2pUBaJtSPgAm9YWwXeHgGzN0E19WCxQUX2PLwgeBn8r/86KOP+PTTT4mPj8fXt4xrdbsBjZBFpKIpkN2EyWTKv4/s7e1dpnNtNhuzZ89m/PjxjB8/nhEjRlw61BuPMdaotpwBYGFE0c1iXyzmfP+boHpzADZs2MDYsWOJi4ujdu3aZardXQQFBbFv376KLkNEKjEFshv5a9q6LIH866+/MmTIEE6fPs3WrVtp2LBh6U68tifsfRGsZ8v+gJfZF+54A4Dk5GT69u3LokWLaNSoUdn6cSMaIYtIRft73ei7EmWkwI4nYGUTfngzB591t0NsB/hlCdiKfy/Zbrfz8ccf06JFC9q3b1+2MAYwe8N9m8C7unE/uNTnVYWmE6Hevzl27BidOnViypQptG/fvvR9uCEFsohUNI2QK8rRDbDnechINoLXbqF+DSD7Z+PPiV1GUDYcCU1eNgL0T8ePH2fYsGEcOHCAdevW0bx58/LV4HcdPJgA69tD7h/509dF8vA26rnzbbhlKNnZ2XTt2pWwsDAGDhxYvuu7EQWyiFQ0jZArwg+zIK4znEz4c8q4iKerLZlwLh1SpsL6eyHPWJUjOjqaZs2a0bBhQ3bt2lX+MP6L33XQOQVazSHDowE55zzA088IYLMveAb8uRXkSOiUDLcMxWazMWDAAG699VbGjx9/edd3EwpkEalo2u3J1X6eDzufBGt26c/x8MFy1W2EL27E5i3bmD9/Pvfcc4/DSwsPD6ftbQEM7NQY8tLB0xd860HdB8Hsk9/uueeeY+fOnaxbtw4fH58Sevz7sFgsVKlShdzcXLfbHlJEKgcFsitl/QorGhqj4jI6mwebjt5JSIRztjC02WzUr1+fuLg4brnllmLbzZ49m7fffpv4+Hhq1Kjh8DoqUs2aNdm/fz9BQUEVXYqIVEK6h+xKP0QW+0RzehY8/gF8lwomE8wLh9YFctHXG/59009Q1Tkj0oSEBAIDA0sM49WrV/PKK6+wZcuWKy6M4fy0tQJZRCqCAtlVrHlw4D2wFb3F36hP4MFmsGQ05Fkgu6hVLe1W+DUarn/Y4eV9+eWXdO3atdjje/fuJSwsjGXLlnHTTTc5/PruQPeRRaQi6aEuVzm6zthDuAins2HzfnisvfG1tydU8yuioeUM/DDTKeXFxMTQpUuXIo/99ttvdOnShZkzZ9KmTRunXN8d1AmqRfrxQyW+biYi4iwaIbtKdirYi/4f/c/HIegqGPw+7P0FWjSAdwaAX5Wi+vnV4aUdPnyY3377jdatW190LDMzk86dO/Pkk0/y8MOOH5lXuLx040G7/dNY3OsXbHkx8NkQ8AqAm4fCrRHGk+giIk6mEbKrWIvf8tBig28PwfD7YPfr4OcDk2OK66fkHZrKIyYmhk6dOl30dLHFYuGRRx6hZcuWjBkzxuHXrVA2C+x6CqLrGiuWZf+CyQRmkxWwGa+cff8OxDSEjf+G3JMVXbGIXOEUyK7iFQgeXkUeql/D+HP3zcbXvVsZAV10PwEOLy0mJuai+8d2u51Ro0Zx7tw5Zs2ahclkcvh1K4w1Fzb+C36aa/yiVNwraLY8sOXAsQ2wurkxyyEi4iQKZFepcWex95CvrgbX1oTvfze+jk2CxtcU0dBkhlr/cGhZp0+fJj4+nn/961+Fvv/222+zefNmFi9ejJdX0b9I/C3Z7bD1EUjbVvp3wW15cPZ3Y0Wzc6edWp6IVF66h+wq1ZuB/42Q8V2Rh2cMhP6zjCesb6wNHw27uE2uBY749uSG8tZgt0NaPGQdAks2eAXwzfbfueeeewq92xwdHc3UqVOJj48nMDCwvFdzT7+vhqNfgfUsQ+bAit1QOwC+M/bKYPF2+N8XkPI77HgFWt7453l2qzFCTpoEzSdVWPkicuXSwiCudHAB7Bxe8prRJTiaU5vbx9ho164dY8aM4a677irdiXnp8PP/GctwnssATGC3gclMbm4Wp6lH0L1ToX53dn67l44dO7JmzRpatGhRrjrd2vr2cDwOgM0p4F8FBr53PpBTfgMPEwybB1P7FQjkv3gFQq8/ir39ICJSXpqydqXrHgLvGmAqx1+72ZerH5zPwYMHCQkJoVevXoSGhrJu3TpK/J3q6HpYdi3sfQnO/mb8MmDJBGsWWE7jY7YSZP4Vtj+GJboBIwd35sMPP7wyw/jMQUjbnv/lvcFQ44JFz4KvgYb1SujDboPUZc6pT0QqNQWyK5l94L448KqGvSx/9flbHj6Iv78/o0aN4qeffiIsLIxnnnmGFi1asGjRIiyWCzapSI2BuK5GCF/qfqnlDKac39k0NpNuHZqU/Wf7O0j9ErjMCSFLpvGalIiIgymQXc3/BngwgRPZVci1XmLa868dl+6cDsHPFjrk5eXFwIEDSUxMZMKECcyYMYOGDRvy3nvvkZOTA6cSjYeXyrButtkDqnjk/vnwUmbZfzZ3l3MMbA54bSzn2OX3ISJyAQVyBVi2fg/tp9WFuyIhoLExAjZXBZMXeFT5c8tDf7jlSej0HdwSXmxfHh4edOnShS1btjB//nxWrlxJgwYN+OGLPtiLCeMbRsHtY6D5C9Dy5QuP2iDvFBz82HE/sLso5j3wCutHRKQAPWXtYidPnmTEiBEsWrQIn0ZtodFQOPmtsTdyXroxIq56DdT7N5iLWqqreG3btqVt27bs372JBt+FYiphenbjy1DrqmIOWrMheYrxC8GV9P6xTy3jl55iVkwrfT81HVOPiEgBCmQXGz16NL1796Zt27bnv1njTuOPgzTy3Axe3saiFuWVdwL++Bpq3+uwuipc3fth3//AagRy35mwKQXSMqF+BEzoDTX8YOR8+CMTOk2B5tfD2rEF+jD7wbW9KqR8EbmyKZBdaMWKFWzdupXExETnXuhobIlhbDLBvyaDCRgWCuEdimhkzTEWz7iSArl680Lvgi+MKLpZjxLfJrPBDY86vDQREQWyi6Snp/PEE0+wYMEC/PyK2srJgfJOlXh463ioVx2OZ8D9k6FRXeMVoELsFsg94bwaK0rjMbDjCeO1r7IyecIN/cHL/9JtRUTKSA91ucgzzzxDt27daN++vfMvZvYp8XC96sbH2oHQoyXs+LmoVibjfvaV5rqHIeAWMHmX/Vyvq+D28Y6vSUQEBbJLrF69mo0bN/LGG2+45oJVi98uMCsHMs+e/3zdPritfhENzb5QtaQVMv6mzN7QYb3x4JxHyb+4nGcynnzvEAtVi/rLEhG5fJqydrKMjAyGDRvGRx99VGi9aKe6ORyOrityic5jp6HHdONzixX6tYEHmxXRh9125T685FMT/r0bNneHEzuMd5OLe5XJ099o/8+1ENDQtXWKSKWitaydLDw8HJPJxPvvv++6i9ptWBbXwdOSVs4OPIwwDvncoWW5pVOJsH86/LLIuEds8gDsxhaNte+Fxs9DnQ7lW+5URKQMFMhO9NVXX/H444+zb98+AgIcv49xUbKysnjttdfwPPA2/+1qwcujHO/cmqtC6Eao1crxBbqrc2eMXbDOnQZPP/C9BqrUquiqRKQS0a/9TpKZmcnQoUOZM2eOS8LYbrezZMkSGjduzOHDh3liWgpede4uw33SP5mrQsOnKlcYg/HkdLXbIKiNsVWmwlhEXEwjZCd58sknyc3NZe7cuU6/1v79+xk5ciRHjx5l5syZtGvXzjhw7jRseADS95ZuTWtzVbhxMLSccWWt0CUi8jegEbITbNiwgZiYGN566y2nXufMmTOMGTOGkJAQOnXqxLfffns+jAG8AozdpW4dCZ5XGQ8oFcXTH3zrGUF810yFsYhIBdAI2cHOnDlD06ZNmTFjBp06dXLKNex2O59//jnPPfcc//znP3nzzTe5+uqrSz7JmgO/LIHv34GsX4yVvDz9oVpTCH7uzweXFMQiIhVFgexgTz31FBkZGcyf75w9c5OSkhg5ciQnTpwgMjKy8JrYIiLyt6UpawfavHkzX3zxBdOnT3d436dPn+bZZ5+lffv29OzZk4SEBIWxiMgVRIHsINnZ2QwZMoTZs2dTo0YNh/Vrt9uJiooiODiYU6dOkZSUREREBJ6eWtNFRORKoilrB3n66ac5fvw4UVFRDutz3759REREkJmZSWRkJK1bt3ZY3yIi4l40QnaArVu38tlnn/Huu+86pL+MjAxGjx5NaGgojzzyCDt37lQYi4hc4RTIl+ns2bMMGTKEyMhIataseVl92e12Pv74Y4KDg8nKyiIpKYnhw4djNpsdVK2IiLgr3Yi8TOPGjaN58+b07NnzsvrZs2cPERER5ObmsmzZMlq1qmQrZYmIVHIK5Muwfft2PvnkE/bt21fuPk6dOsV///tfFi9ezMSJE3nsscc0IhYRqYQ0ZV1OOTk5DB48mHfffZegoKAyn2+z2Zg3bx7BwcFYrVaSk5MJDw9XGIuIVFIaIZfThAkTCA4O5qGHHirzuQkJCURERGC321mxYgUtW7Z0QoUiIvJ3okAuh127djFv3jwSExMxlWG5yZMnT/LSSy8RHR3N66+/zqBBg/Dw0CSFiIhoyrrMcnNzGTx4MNOnT6dOnTqlOsdms/HBBx8QHByM2WwmJSWFIUOGKIxFRCSfRshl9Oqrr3Ljjc8szVMAAASFSURBVDfSt2/fUrXfuXMnI0aMwMvLi7Vr19K8eXMnVygiIn9HWqmrDHbv3s0DDzzA3r17qVu3bolt09LSePHFF4mJiWHy5MkMGDBAI2IRESmWEqKU8vLyGDx4MFOnTi0xjK1WK7Nnz6Zx48b4+vqSkpJCWFiYwlhEREqkKetSmjRpEtdccw0DBgwots22bdsYMWIEfn5+rF+/nqZNm7qwQhER+TvTlLXdDsc2QspUOJkA1izw8AbfenBrBNzwKIkpPxMaGsru3bupX7/+RV0cP36csWPHsnbtWt5880369etXpqevRUREKncgH1wAe16Ac+lgOXPxcbMfdmx8keBHVqNXCBsyvNBhi8XCe++9x4QJExg4cCDjx48nICDARcWLiMiVpHIGst0Oe8bCDzPBmn3J5rkWD7xrBGO6bxNUqQUYOzyNGDGC6tWrM3PmTJo0aeLkokVE5EpWOQP5u9cg6fVShXE+kxcENOJo8+WMefF/xMbGMnXqVPr06aPpaRERuWyV76Gu9CRIeg2sZ8t2nv0c506lsOjlJtSpE0FKSgpXXXWVc2oUEZFKp/KNkLc9Dgf/D+xWhsyBFbuhdgB898b5JjPWwsyvwNMDOjWHN/udP2b18Mf80Akwe7u8dBERuXJVrpdjz2XC4U/BbgVgUAiseb5wk41JsDwBEidB0pvwXKfCx80eJkiNdlHBIiJSWVSuQP5tJZjOz9LfGww1/As3mR0LY7uCj5fxde3AC/qwZMKP7zm3ThERqXQqVyDnHAFbbolNfjgCX++Hu8dBu4mw86ciGp393Tn1iYhIpVW5AtmWB3ZbiU0sNjiVBdsmwJR+8PAM4y2pi/oRERFxoMoVyF7VwMOrxCb1a0DPu8BkglY3gYcJ0jIv7OfCeWwREZHLU7kCuVbrSzbp3gI2JBuf/3AE8ixQq+DbTR7ecHWoc+oTEZFKq/K99rSqGaQnAtB3JmxKMUbAdQJgQm8Y0BaGzIE9h8HbE6b2gw4FF+HyqAKdU8D/hgopX0RErkyVL5APfQo7hhW9dnVp1G4P9210aEkiIiKVa8oa4Npe4Fu30OtPpWauCs3fuHQ7ERGRMqp8gWz2gdBN4FOzbKFs9oV/zINarZxWmoiIVF6Vb8r6L2ePQmwHyP615Olrc1XjY9vP4ZpOxbcTERG5DJU3kAFsVjiyBpLfhBM7jPWp7TaMiQMbeAVAo2fhpsHgXb2iqxURkStY5Q7kgs4cgvS9kJcOnlXBtz7UuhtMlW9WX0REXE+BLCIi4gY0/BMREXEDCmQRERE3oEAWERFxAwpkERERN6BAFhERcQMKZBERETegQBYREXEDCmQRERE3oEAWERFxAwpkERERN6BAFhERcQMKZBERETegQBYREXEDCmQRERE3oEAWERFxAwpkERERN6BAFhERcQMKZBERETegQBYREXEDCmQRERE3oEAWERFxAwpkERERN6BAFhERcQMKZBERETegQBYREXEDCmQRERE3oEAWERFxAwpkERERN6BAFhERcQMKZBERETegQBYREXED/w8y8EiNQZAodQAAAABJRU5ErkJggg==\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "nx.draw(G, pos = my_pos, with_labels=True, node_color=color_map, node_size=300, edge_color='black', linewidths=1, font_size=10)\n",
    "plt.savefig(\"my_result.png\")\n",
    "plt.show() "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [],
   "source": [
    "cut_list = []"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [],
   "source": [
    "cut_dict = {}"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
